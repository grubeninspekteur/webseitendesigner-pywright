Created by PLY version 3.4 (http://www.dabeaz.com/ply)

Unused terminals:

    MULTCOMMENT
    COMMENT

Grammar

Rule 0     S' -> start
Rule 1     start -> NEWLINE statements optspace
Rule 2     start -> statements optspace
Rule 3     statements -> statements NEWLINE statement
Rule 4     statements -> statement
Rule 5     statement -> expression
Rule 6     statement -> LABEL IDENTIFIER
Rule 7     expression -> IDENTIFIER args
Rule 8     expression -> STRING
Rule 9     statement -> RESUME
Rule 10    statement -> GOTO IDENTIFIER
Rule 11    expression -> IS arg thenexpr elseexpr
Rule 12    expression -> EXIT
Rule 13    statement -> DEF IDENTIFIER params NEWLINE expressions NEWLINE ENDDEF
Rule 14    params -> empty
Rule 15    params -> params IDENTIFIER
Rule 16    expressions -> expressions NEWLINE expression
Rule 17    expressions -> expressions NEWLINE returner
Rule 18    expressions -> expression
Rule 19    expressions -> returner
Rule 20    returner -> RETURN
Rule 21    returner -> RETURN arg
Rule 22    thenexpr -> GOTO IDENTIFIER
Rule 23    thenexpr -> funcall
Rule 24    elseexpr -> ELSE thenexpr
Rule 25    elseexpr -> empty
Rule 26    funcall -> IDENTIFIER args
Rule 27    args -> empty
Rule 28    args -> args arg
Rule 29    arg -> IDENTIFIER
Rule 30    arg -> list
Rule 31    arg -> literal
Rule 32    literal -> STRING
Rule 33    literal -> NUMBER
Rule 34    literal -> BOOLEAN
Rule 35    arg -> LPAREN funcall RPAREN
Rule 36    list -> LBRACKET optspace listelems optspace RBRACKET
Rule 37    list -> LBRACKET optspace listelems optspace COMMA RBRACKET
Rule 38    list -> LBRACKET optspace RBRACKET
Rule 39    listelems -> arg
Rule 40    listelems -> listelems optspace COMMA optspace arg
Rule 41    optspace -> empty
Rule 42    optspace -> NEWLINE
Rule 43    empty -> <empty>

Terminals, with rules where they appear

BOOLEAN              : 34
COMMA                : 37 40
COMMENT              : 
DEF                  : 13
ELSE                 : 24
ENDDEF               : 13
EXIT                 : 12
GOTO                 : 10 22
IDENTIFIER           : 6 7 10 13 15 22 26 29
IS                   : 11
LABEL                : 6
LBRACKET             : 36 37 38
LPAREN               : 35
MULTCOMMENT          : 
NEWLINE              : 1 3 13 13 16 17 42
NUMBER               : 33
RBRACKET             : 36 37 38
RESUME               : 9
RETURN               : 20 21
RPAREN               : 35
STRING               : 8 32
error                : 

Nonterminals, with rules where they appear

arg                  : 11 21 28 39 40
args                 : 7 26 28
elseexpr             : 11
empty                : 14 25 27 41
expression           : 5 16 18
expressions          : 13 16 17
funcall              : 23 35
list                 : 30
listelems            : 36 37 40
literal              : 31
optspace             : 1 2 36 36 37 37 38 40 40
params               : 13 15
returner             : 17 19
start                : 0
statement            : 3 4
statements           : 1 2 3
thenexpr             : 11 24

Parsing method: LALR

state 0

    (0) S' -> . start
    (1) start -> . NEWLINE statements optspace
    (2) start -> . statements optspace
    (3) statements -> . statements NEWLINE statement
    (4) statements -> . statement
    (5) statement -> . expression
    (6) statement -> . LABEL IDENTIFIER
    (9) statement -> . RESUME
    (10) statement -> . GOTO IDENTIFIER
    (13) statement -> . DEF IDENTIFIER params NEWLINE expressions NEWLINE ENDDEF
    (7) expression -> . IDENTIFIER args
    (8) expression -> . STRING
    (11) expression -> . IS arg thenexpr elseexpr
    (12) expression -> . EXIT

    NEWLINE         shift and go to state 6
    LABEL           shift and go to state 7
    RESUME          shift and go to state 4
    GOTO            shift and go to state 3
    DEF             shift and go to state 12
    IDENTIFIER      shift and go to state 1
    STRING          shift and go to state 13
    IS              shift and go to state 5
    EXIT            shift and go to state 10

    statements                     shift and go to state 2
    start                          shift and go to state 8
    statement                      shift and go to state 9
    expression                     shift and go to state 11

state 1

    (7) expression -> IDENTIFIER . args
    (27) args -> . empty
    (28) args -> . args arg
    (43) empty -> .

    IDENTIFIER      reduce using rule 43 (empty -> .)
    LPAREN          reduce using rule 43 (empty -> .)
    LBRACKET        reduce using rule 43 (empty -> .)
    STRING          reduce using rule 43 (empty -> .)
    NUMBER          reduce using rule 43 (empty -> .)
    BOOLEAN         reduce using rule 43 (empty -> .)
    NEWLINE         reduce using rule 43 (empty -> .)
    $end            reduce using rule 43 (empty -> .)

    args                           shift and go to state 15
    empty                          shift and go to state 14

state 2

    (2) start -> statements . optspace
    (3) statements -> statements . NEWLINE statement
    (41) optspace -> . empty
    (42) optspace -> . NEWLINE
    (43) empty -> .

    NEWLINE         shift and go to state 16
    $end            reduce using rule 43 (empty -> .)

    optspace                       shift and go to state 17
    empty                          shift and go to state 18

state 3

    (10) statement -> GOTO . IDENTIFIER

    IDENTIFIER      shift and go to state 19


state 4

    (9) statement -> RESUME .

    NEWLINE         reduce using rule 9 (statement -> RESUME .)
    $end            reduce using rule 9 (statement -> RESUME .)


state 5

    (11) expression -> IS . arg thenexpr elseexpr
    (29) arg -> . IDENTIFIER
    (30) arg -> . list
    (31) arg -> . literal
    (35) arg -> . LPAREN funcall RPAREN
    (36) list -> . LBRACKET optspace listelems optspace RBRACKET
    (37) list -> . LBRACKET optspace listelems optspace COMMA RBRACKET
    (38) list -> . LBRACKET optspace RBRACKET
    (32) literal -> . STRING
    (33) literal -> . NUMBER
    (34) literal -> . BOOLEAN

    IDENTIFIER      shift and go to state 28
    LPAREN          shift and go to state 26
    LBRACKET        shift and go to state 20
    STRING          shift and go to state 21
    NUMBER          shift and go to state 23
    BOOLEAN         shift and go to state 25

    list                           shift and go to state 22
    literal                        shift and go to state 24
    arg                            shift and go to state 27

state 6

    (1) start -> NEWLINE . statements optspace
    (3) statements -> . statements NEWLINE statement
    (4) statements -> . statement
    (5) statement -> . expression
    (6) statement -> . LABEL IDENTIFIER
    (9) statement -> . RESUME
    (10) statement -> . GOTO IDENTIFIER
    (13) statement -> . DEF IDENTIFIER params NEWLINE expressions NEWLINE ENDDEF
    (7) expression -> . IDENTIFIER args
    (8) expression -> . STRING
    (11) expression -> . IS arg thenexpr elseexpr
    (12) expression -> . EXIT

    LABEL           shift and go to state 7
    RESUME          shift and go to state 4
    GOTO            shift and go to state 3
    DEF             shift and go to state 12
    IDENTIFIER      shift and go to state 1
    STRING          shift and go to state 13
    IS              shift and go to state 5
    EXIT            shift and go to state 10

    statements                     shift and go to state 29
    statement                      shift and go to state 9
    expression                     shift and go to state 11

state 7

    (6) statement -> LABEL . IDENTIFIER

    IDENTIFIER      shift and go to state 30


state 8

    (0) S' -> start .



state 9

    (4) statements -> statement .

    NEWLINE         reduce using rule 4 (statements -> statement .)
    $end            reduce using rule 4 (statements -> statement .)


state 10

    (12) expression -> EXIT .

    NEWLINE         reduce using rule 12 (expression -> EXIT .)
    $end            reduce using rule 12 (expression -> EXIT .)


state 11

    (5) statement -> expression .

    NEWLINE         reduce using rule 5 (statement -> expression .)
    $end            reduce using rule 5 (statement -> expression .)


state 12

    (13) statement -> DEF . IDENTIFIER params NEWLINE expressions NEWLINE ENDDEF

    IDENTIFIER      shift and go to state 31


state 13

    (8) expression -> STRING .

    NEWLINE         reduce using rule 8 (expression -> STRING .)
    $end            reduce using rule 8 (expression -> STRING .)


state 14

    (27) args -> empty .

    IDENTIFIER      reduce using rule 27 (args -> empty .)
    LPAREN          reduce using rule 27 (args -> empty .)
    LBRACKET        reduce using rule 27 (args -> empty .)
    STRING          reduce using rule 27 (args -> empty .)
    NUMBER          reduce using rule 27 (args -> empty .)
    BOOLEAN         reduce using rule 27 (args -> empty .)
    RPAREN          reduce using rule 27 (args -> empty .)
    ELSE            reduce using rule 27 (args -> empty .)
    NEWLINE         reduce using rule 27 (args -> empty .)
    $end            reduce using rule 27 (args -> empty .)


state 15

    (7) expression -> IDENTIFIER args .
    (28) args -> args . arg
    (29) arg -> . IDENTIFIER
    (30) arg -> . list
    (31) arg -> . literal
    (35) arg -> . LPAREN funcall RPAREN
    (36) list -> . LBRACKET optspace listelems optspace RBRACKET
    (37) list -> . LBRACKET optspace listelems optspace COMMA RBRACKET
    (38) list -> . LBRACKET optspace RBRACKET
    (32) literal -> . STRING
    (33) literal -> . NUMBER
    (34) literal -> . BOOLEAN

    NEWLINE         reduce using rule 7 (expression -> IDENTIFIER args .)
    $end            reduce using rule 7 (expression -> IDENTIFIER args .)
    IDENTIFIER      shift and go to state 28
    LPAREN          shift and go to state 26
    LBRACKET        shift and go to state 20
    STRING          shift and go to state 21
    NUMBER          shift and go to state 23
    BOOLEAN         shift and go to state 25

    list                           shift and go to state 22
    literal                        shift and go to state 24
    arg                            shift and go to state 32

state 16

    (3) statements -> statements NEWLINE . statement
    (42) optspace -> NEWLINE .
    (5) statement -> . expression
    (6) statement -> . LABEL IDENTIFIER
    (9) statement -> . RESUME
    (10) statement -> . GOTO IDENTIFIER
    (13) statement -> . DEF IDENTIFIER params NEWLINE expressions NEWLINE ENDDEF
    (7) expression -> . IDENTIFIER args
    (8) expression -> . STRING
    (11) expression -> . IS arg thenexpr elseexpr
    (12) expression -> . EXIT

    $end            reduce using rule 42 (optspace -> NEWLINE .)
    LABEL           shift and go to state 7
    RESUME          shift and go to state 4
    GOTO            shift and go to state 3
    DEF             shift and go to state 12
    IDENTIFIER      shift and go to state 1
    STRING          shift and go to state 13
    IS              shift and go to state 5
    EXIT            shift and go to state 10

    statement                      shift and go to state 33
    expression                     shift and go to state 11

state 17

    (2) start -> statements optspace .

    $end            reduce using rule 2 (start -> statements optspace .)


state 18

    (41) optspace -> empty .

    $end            reduce using rule 41 (optspace -> empty .)
    RBRACKET        reduce using rule 41 (optspace -> empty .)
    COMMA           reduce using rule 41 (optspace -> empty .)
    IDENTIFIER      reduce using rule 41 (optspace -> empty .)
    LPAREN          reduce using rule 41 (optspace -> empty .)
    LBRACKET        reduce using rule 41 (optspace -> empty .)
    STRING          reduce using rule 41 (optspace -> empty .)
    NUMBER          reduce using rule 41 (optspace -> empty .)
    BOOLEAN         reduce using rule 41 (optspace -> empty .)


state 19

    (10) statement -> GOTO IDENTIFIER .

    NEWLINE         reduce using rule 10 (statement -> GOTO IDENTIFIER .)
    $end            reduce using rule 10 (statement -> GOTO IDENTIFIER .)


state 20

    (36) list -> LBRACKET . optspace listelems optspace RBRACKET
    (37) list -> LBRACKET . optspace listelems optspace COMMA RBRACKET
    (38) list -> LBRACKET . optspace RBRACKET
    (41) optspace -> . empty
    (42) optspace -> . NEWLINE
    (43) empty -> .

    NEWLINE         shift and go to state 34
    RBRACKET        reduce using rule 43 (empty -> .)
    IDENTIFIER      reduce using rule 43 (empty -> .)
    LPAREN          reduce using rule 43 (empty -> .)
    LBRACKET        reduce using rule 43 (empty -> .)
    STRING          reduce using rule 43 (empty -> .)
    NUMBER          reduce using rule 43 (empty -> .)
    BOOLEAN         reduce using rule 43 (empty -> .)

    optspace                       shift and go to state 35
    empty                          shift and go to state 18

state 21

    (32) literal -> STRING .

    NEWLINE         reduce using rule 32 (literal -> STRING .)
    GOTO            reduce using rule 32 (literal -> STRING .)
    IDENTIFIER      reduce using rule 32 (literal -> STRING .)
    LPAREN          reduce using rule 32 (literal -> STRING .)
    LBRACKET        reduce using rule 32 (literal -> STRING .)
    STRING          reduce using rule 32 (literal -> STRING .)
    NUMBER          reduce using rule 32 (literal -> STRING .)
    BOOLEAN         reduce using rule 32 (literal -> STRING .)
    $end            reduce using rule 32 (literal -> STRING .)
    RBRACKET        reduce using rule 32 (literal -> STRING .)
    COMMA           reduce using rule 32 (literal -> STRING .)
    RPAREN          reduce using rule 32 (literal -> STRING .)
    ELSE            reduce using rule 32 (literal -> STRING .)


state 22

    (30) arg -> list .

    GOTO            reduce using rule 30 (arg -> list .)
    IDENTIFIER      reduce using rule 30 (arg -> list .)
    LPAREN          reduce using rule 30 (arg -> list .)
    LBRACKET        reduce using rule 30 (arg -> list .)
    STRING          reduce using rule 30 (arg -> list .)
    NUMBER          reduce using rule 30 (arg -> list .)
    BOOLEAN         reduce using rule 30 (arg -> list .)
    NEWLINE         reduce using rule 30 (arg -> list .)
    $end            reduce using rule 30 (arg -> list .)
    RBRACKET        reduce using rule 30 (arg -> list .)
    COMMA           reduce using rule 30 (arg -> list .)
    RPAREN          reduce using rule 30 (arg -> list .)
    ELSE            reduce using rule 30 (arg -> list .)


state 23

    (33) literal -> NUMBER .

    NEWLINE         reduce using rule 33 (literal -> NUMBER .)
    GOTO            reduce using rule 33 (literal -> NUMBER .)
    IDENTIFIER      reduce using rule 33 (literal -> NUMBER .)
    LPAREN          reduce using rule 33 (literal -> NUMBER .)
    LBRACKET        reduce using rule 33 (literal -> NUMBER .)
    STRING          reduce using rule 33 (literal -> NUMBER .)
    NUMBER          reduce using rule 33 (literal -> NUMBER .)
    BOOLEAN         reduce using rule 33 (literal -> NUMBER .)
    $end            reduce using rule 33 (literal -> NUMBER .)
    RBRACKET        reduce using rule 33 (literal -> NUMBER .)
    COMMA           reduce using rule 33 (literal -> NUMBER .)
    RPAREN          reduce using rule 33 (literal -> NUMBER .)
    ELSE            reduce using rule 33 (literal -> NUMBER .)


state 24

    (31) arg -> literal .

    GOTO            reduce using rule 31 (arg -> literal .)
    IDENTIFIER      reduce using rule 31 (arg -> literal .)
    LPAREN          reduce using rule 31 (arg -> literal .)
    LBRACKET        reduce using rule 31 (arg -> literal .)
    STRING          reduce using rule 31 (arg -> literal .)
    NUMBER          reduce using rule 31 (arg -> literal .)
    BOOLEAN         reduce using rule 31 (arg -> literal .)
    NEWLINE         reduce using rule 31 (arg -> literal .)
    $end            reduce using rule 31 (arg -> literal .)
    RBRACKET        reduce using rule 31 (arg -> literal .)
    COMMA           reduce using rule 31 (arg -> literal .)
    RPAREN          reduce using rule 31 (arg -> literal .)
    ELSE            reduce using rule 31 (arg -> literal .)


state 25

    (34) literal -> BOOLEAN .

    NEWLINE         reduce using rule 34 (literal -> BOOLEAN .)
    GOTO            reduce using rule 34 (literal -> BOOLEAN .)
    IDENTIFIER      reduce using rule 34 (literal -> BOOLEAN .)
    LPAREN          reduce using rule 34 (literal -> BOOLEAN .)
    LBRACKET        reduce using rule 34 (literal -> BOOLEAN .)
    STRING          reduce using rule 34 (literal -> BOOLEAN .)
    NUMBER          reduce using rule 34 (literal -> BOOLEAN .)
    BOOLEAN         reduce using rule 34 (literal -> BOOLEAN .)
    $end            reduce using rule 34 (literal -> BOOLEAN .)
    RBRACKET        reduce using rule 34 (literal -> BOOLEAN .)
    COMMA           reduce using rule 34 (literal -> BOOLEAN .)
    RPAREN          reduce using rule 34 (literal -> BOOLEAN .)
    ELSE            reduce using rule 34 (literal -> BOOLEAN .)


state 26

    (35) arg -> LPAREN . funcall RPAREN
    (26) funcall -> . IDENTIFIER args

    IDENTIFIER      shift and go to state 37

    funcall                        shift and go to state 36

state 27

    (11) expression -> IS arg . thenexpr elseexpr
    (22) thenexpr -> . GOTO IDENTIFIER
    (23) thenexpr -> . funcall
    (26) funcall -> . IDENTIFIER args

    GOTO            shift and go to state 38
    IDENTIFIER      shift and go to state 37

    funcall                        shift and go to state 39
    thenexpr                       shift and go to state 40

state 28

    (29) arg -> IDENTIFIER .

    GOTO            reduce using rule 29 (arg -> IDENTIFIER .)
    IDENTIFIER      reduce using rule 29 (arg -> IDENTIFIER .)
    LPAREN          reduce using rule 29 (arg -> IDENTIFIER .)
    LBRACKET        reduce using rule 29 (arg -> IDENTIFIER .)
    STRING          reduce using rule 29 (arg -> IDENTIFIER .)
    NUMBER          reduce using rule 29 (arg -> IDENTIFIER .)
    BOOLEAN         reduce using rule 29 (arg -> IDENTIFIER .)
    NEWLINE         reduce using rule 29 (arg -> IDENTIFIER .)
    $end            reduce using rule 29 (arg -> IDENTIFIER .)
    RBRACKET        reduce using rule 29 (arg -> IDENTIFIER .)
    COMMA           reduce using rule 29 (arg -> IDENTIFIER .)
    RPAREN          reduce using rule 29 (arg -> IDENTIFIER .)
    ELSE            reduce using rule 29 (arg -> IDENTIFIER .)


state 29

    (1) start -> NEWLINE statements . optspace
    (3) statements -> statements . NEWLINE statement
    (41) optspace -> . empty
    (42) optspace -> . NEWLINE
    (43) empty -> .

    NEWLINE         shift and go to state 16
    $end            reduce using rule 43 (empty -> .)

    optspace                       shift and go to state 41
    empty                          shift and go to state 18

state 30

    (6) statement -> LABEL IDENTIFIER .

    NEWLINE         reduce using rule 6 (statement -> LABEL IDENTIFIER .)
    $end            reduce using rule 6 (statement -> LABEL IDENTIFIER .)


state 31

    (13) statement -> DEF IDENTIFIER . params NEWLINE expressions NEWLINE ENDDEF
    (14) params -> . empty
    (15) params -> . params IDENTIFIER
    (43) empty -> .

    NEWLINE         reduce using rule 43 (empty -> .)
    IDENTIFIER      reduce using rule 43 (empty -> .)

    params                         shift and go to state 42
    empty                          shift and go to state 43

state 32

    (28) args -> args arg .

    IDENTIFIER      reduce using rule 28 (args -> args arg .)
    LPAREN          reduce using rule 28 (args -> args arg .)
    LBRACKET        reduce using rule 28 (args -> args arg .)
    STRING          reduce using rule 28 (args -> args arg .)
    NUMBER          reduce using rule 28 (args -> args arg .)
    BOOLEAN         reduce using rule 28 (args -> args arg .)
    RPAREN          reduce using rule 28 (args -> args arg .)
    ELSE            reduce using rule 28 (args -> args arg .)
    NEWLINE         reduce using rule 28 (args -> args arg .)
    $end            reduce using rule 28 (args -> args arg .)


state 33

    (3) statements -> statements NEWLINE statement .

    NEWLINE         reduce using rule 3 (statements -> statements NEWLINE statement .)
    $end            reduce using rule 3 (statements -> statements NEWLINE statement .)


state 34

    (42) optspace -> NEWLINE .

    RBRACKET        reduce using rule 42 (optspace -> NEWLINE .)
    COMMA           reduce using rule 42 (optspace -> NEWLINE .)
    IDENTIFIER      reduce using rule 42 (optspace -> NEWLINE .)
    LPAREN          reduce using rule 42 (optspace -> NEWLINE .)
    LBRACKET        reduce using rule 42 (optspace -> NEWLINE .)
    STRING          reduce using rule 42 (optspace -> NEWLINE .)
    NUMBER          reduce using rule 42 (optspace -> NEWLINE .)
    BOOLEAN         reduce using rule 42 (optspace -> NEWLINE .)


state 35

    (36) list -> LBRACKET optspace . listelems optspace RBRACKET
    (37) list -> LBRACKET optspace . listelems optspace COMMA RBRACKET
    (38) list -> LBRACKET optspace . RBRACKET
    (39) listelems -> . arg
    (40) listelems -> . listelems optspace COMMA optspace arg
    (29) arg -> . IDENTIFIER
    (30) arg -> . list
    (31) arg -> . literal
    (35) arg -> . LPAREN funcall RPAREN
    (36) list -> . LBRACKET optspace listelems optspace RBRACKET
    (37) list -> . LBRACKET optspace listelems optspace COMMA RBRACKET
    (38) list -> . LBRACKET optspace RBRACKET
    (32) literal -> . STRING
    (33) literal -> . NUMBER
    (34) literal -> . BOOLEAN

    RBRACKET        shift and go to state 46
    IDENTIFIER      shift and go to state 28
    LPAREN          shift and go to state 26
    LBRACKET        shift and go to state 20
    STRING          shift and go to state 21
    NUMBER          shift and go to state 23
    BOOLEAN         shift and go to state 25

    listelems                      shift and go to state 44
    list                           shift and go to state 22
    literal                        shift and go to state 24
    arg                            shift and go to state 45

state 36

    (35) arg -> LPAREN funcall . RPAREN

    RPAREN          shift and go to state 47


state 37

    (26) funcall -> IDENTIFIER . args
    (27) args -> . empty
    (28) args -> . args arg
    (43) empty -> .

    IDENTIFIER      reduce using rule 43 (empty -> .)
    LPAREN          reduce using rule 43 (empty -> .)
    LBRACKET        reduce using rule 43 (empty -> .)
    STRING          reduce using rule 43 (empty -> .)
    NUMBER          reduce using rule 43 (empty -> .)
    BOOLEAN         reduce using rule 43 (empty -> .)
    RPAREN          reduce using rule 43 (empty -> .)
    ELSE            reduce using rule 43 (empty -> .)
    NEWLINE         reduce using rule 43 (empty -> .)
    $end            reduce using rule 43 (empty -> .)

    args                           shift and go to state 48
    empty                          shift and go to state 14

state 38

    (22) thenexpr -> GOTO . IDENTIFIER

    IDENTIFIER      shift and go to state 49


state 39

    (23) thenexpr -> funcall .

    NEWLINE         reduce using rule 23 (thenexpr -> funcall .)
    $end            reduce using rule 23 (thenexpr -> funcall .)
    ELSE            reduce using rule 23 (thenexpr -> funcall .)


state 40

    (11) expression -> IS arg thenexpr . elseexpr
    (24) elseexpr -> . ELSE thenexpr
    (25) elseexpr -> . empty
    (43) empty -> .

    ELSE            shift and go to state 50
    NEWLINE         reduce using rule 43 (empty -> .)
    $end            reduce using rule 43 (empty -> .)

    empty                          shift and go to state 52
    elseexpr                       shift and go to state 51

state 41

    (1) start -> NEWLINE statements optspace .

    $end            reduce using rule 1 (start -> NEWLINE statements optspace .)


state 42

    (13) statement -> DEF IDENTIFIER params . NEWLINE expressions NEWLINE ENDDEF
    (15) params -> params . IDENTIFIER

    NEWLINE         shift and go to state 53
    IDENTIFIER      shift and go to state 54


state 43

    (14) params -> empty .

    NEWLINE         reduce using rule 14 (params -> empty .)
    IDENTIFIER      reduce using rule 14 (params -> empty .)


state 44

    (36) list -> LBRACKET optspace listelems . optspace RBRACKET
    (37) list -> LBRACKET optspace listelems . optspace COMMA RBRACKET
    (40) listelems -> listelems . optspace COMMA optspace arg
    (41) optspace -> . empty
    (42) optspace -> . NEWLINE
    (43) empty -> .

    NEWLINE         shift and go to state 34
    RBRACKET        reduce using rule 43 (empty -> .)
    COMMA           reduce using rule 43 (empty -> .)

    optspace                       shift and go to state 55
    empty                          shift and go to state 18

state 45

    (39) listelems -> arg .

    NEWLINE         reduce using rule 39 (listelems -> arg .)
    RBRACKET        reduce using rule 39 (listelems -> arg .)
    COMMA           reduce using rule 39 (listelems -> arg .)


state 46

    (38) list -> LBRACKET optspace RBRACKET .

    NEWLINE         reduce using rule 38 (list -> LBRACKET optspace RBRACKET .)
    IDENTIFIER      reduce using rule 38 (list -> LBRACKET optspace RBRACKET .)
    LPAREN          reduce using rule 38 (list -> LBRACKET optspace RBRACKET .)
    LBRACKET        reduce using rule 38 (list -> LBRACKET optspace RBRACKET .)
    STRING          reduce using rule 38 (list -> LBRACKET optspace RBRACKET .)
    NUMBER          reduce using rule 38 (list -> LBRACKET optspace RBRACKET .)
    BOOLEAN         reduce using rule 38 (list -> LBRACKET optspace RBRACKET .)
    RPAREN          reduce using rule 38 (list -> LBRACKET optspace RBRACKET .)
    ELSE            reduce using rule 38 (list -> LBRACKET optspace RBRACKET .)
    $end            reduce using rule 38 (list -> LBRACKET optspace RBRACKET .)
    GOTO            reduce using rule 38 (list -> LBRACKET optspace RBRACKET .)
    RBRACKET        reduce using rule 38 (list -> LBRACKET optspace RBRACKET .)
    COMMA           reduce using rule 38 (list -> LBRACKET optspace RBRACKET .)


state 47

    (35) arg -> LPAREN funcall RPAREN .

    GOTO            reduce using rule 35 (arg -> LPAREN funcall RPAREN .)
    IDENTIFIER      reduce using rule 35 (arg -> LPAREN funcall RPAREN .)
    LPAREN          reduce using rule 35 (arg -> LPAREN funcall RPAREN .)
    LBRACKET        reduce using rule 35 (arg -> LPAREN funcall RPAREN .)
    STRING          reduce using rule 35 (arg -> LPAREN funcall RPAREN .)
    NUMBER          reduce using rule 35 (arg -> LPAREN funcall RPAREN .)
    BOOLEAN         reduce using rule 35 (arg -> LPAREN funcall RPAREN .)
    NEWLINE         reduce using rule 35 (arg -> LPAREN funcall RPAREN .)
    $end            reduce using rule 35 (arg -> LPAREN funcall RPAREN .)
    RBRACKET        reduce using rule 35 (arg -> LPAREN funcall RPAREN .)
    COMMA           reduce using rule 35 (arg -> LPAREN funcall RPAREN .)
    RPAREN          reduce using rule 35 (arg -> LPAREN funcall RPAREN .)
    ELSE            reduce using rule 35 (arg -> LPAREN funcall RPAREN .)


state 48

    (26) funcall -> IDENTIFIER args .
    (28) args -> args . arg
    (29) arg -> . IDENTIFIER
    (30) arg -> . list
    (31) arg -> . literal
    (35) arg -> . LPAREN funcall RPAREN
    (36) list -> . LBRACKET optspace listelems optspace RBRACKET
    (37) list -> . LBRACKET optspace listelems optspace COMMA RBRACKET
    (38) list -> . LBRACKET optspace RBRACKET
    (32) literal -> . STRING
    (33) literal -> . NUMBER
    (34) literal -> . BOOLEAN

    RPAREN          reduce using rule 26 (funcall -> IDENTIFIER args .)
    ELSE            reduce using rule 26 (funcall -> IDENTIFIER args .)
    NEWLINE         reduce using rule 26 (funcall -> IDENTIFIER args .)
    $end            reduce using rule 26 (funcall -> IDENTIFIER args .)
    IDENTIFIER      shift and go to state 28
    LPAREN          shift and go to state 26
    LBRACKET        shift and go to state 20
    STRING          shift and go to state 21
    NUMBER          shift and go to state 23
    BOOLEAN         shift and go to state 25

    list                           shift and go to state 22
    literal                        shift and go to state 24
    arg                            shift and go to state 32

state 49

    (22) thenexpr -> GOTO IDENTIFIER .

    NEWLINE         reduce using rule 22 (thenexpr -> GOTO IDENTIFIER .)
    $end            reduce using rule 22 (thenexpr -> GOTO IDENTIFIER .)
    ELSE            reduce using rule 22 (thenexpr -> GOTO IDENTIFIER .)


state 50

    (24) elseexpr -> ELSE . thenexpr
    (22) thenexpr -> . GOTO IDENTIFIER
    (23) thenexpr -> . funcall
    (26) funcall -> . IDENTIFIER args

    GOTO            shift and go to state 38
    IDENTIFIER      shift and go to state 37

    funcall                        shift and go to state 39
    thenexpr                       shift and go to state 56

state 51

    (11) expression -> IS arg thenexpr elseexpr .

    NEWLINE         reduce using rule 11 (expression -> IS arg thenexpr elseexpr .)
    $end            reduce using rule 11 (expression -> IS arg thenexpr elseexpr .)


state 52

    (25) elseexpr -> empty .

    NEWLINE         reduce using rule 25 (elseexpr -> empty .)
    $end            reduce using rule 25 (elseexpr -> empty .)


state 53

    (13) statement -> DEF IDENTIFIER params NEWLINE . expressions NEWLINE ENDDEF
    (16) expressions -> . expressions NEWLINE expression
    (17) expressions -> . expressions NEWLINE returner
    (18) expressions -> . expression
    (19) expressions -> . returner
    (7) expression -> . IDENTIFIER args
    (8) expression -> . STRING
    (11) expression -> . IS arg thenexpr elseexpr
    (12) expression -> . EXIT
    (20) returner -> . RETURN
    (21) returner -> . RETURN arg

    IDENTIFIER      shift and go to state 1
    STRING          shift and go to state 13
    IS              shift and go to state 5
    EXIT            shift and go to state 10
    RETURN          shift and go to state 57

    returner                       shift and go to state 58
    expressions                    shift and go to state 59
    expression                     shift and go to state 60

state 54

    (15) params -> params IDENTIFIER .

    NEWLINE         reduce using rule 15 (params -> params IDENTIFIER .)
    IDENTIFIER      reduce using rule 15 (params -> params IDENTIFIER .)


state 55

    (36) list -> LBRACKET optspace listelems optspace . RBRACKET
    (37) list -> LBRACKET optspace listelems optspace . COMMA RBRACKET
    (40) listelems -> listelems optspace . COMMA optspace arg

    RBRACKET        shift and go to state 62
    COMMA           shift and go to state 61


state 56

    (24) elseexpr -> ELSE thenexpr .

    NEWLINE         reduce using rule 24 (elseexpr -> ELSE thenexpr .)
    $end            reduce using rule 24 (elseexpr -> ELSE thenexpr .)


state 57

    (20) returner -> RETURN .
    (21) returner -> RETURN . arg
    (29) arg -> . IDENTIFIER
    (30) arg -> . list
    (31) arg -> . literal
    (35) arg -> . LPAREN funcall RPAREN
    (36) list -> . LBRACKET optspace listelems optspace RBRACKET
    (37) list -> . LBRACKET optspace listelems optspace COMMA RBRACKET
    (38) list -> . LBRACKET optspace RBRACKET
    (32) literal -> . STRING
    (33) literal -> . NUMBER
    (34) literal -> . BOOLEAN

    NEWLINE         reduce using rule 20 (returner -> RETURN .)
    IDENTIFIER      shift and go to state 28
    LPAREN          shift and go to state 26
    LBRACKET        shift and go to state 20
    STRING          shift and go to state 21
    NUMBER          shift and go to state 23
    BOOLEAN         shift and go to state 25

    list                           shift and go to state 22
    literal                        shift and go to state 24
    arg                            shift and go to state 63

state 58

    (19) expressions -> returner .

    NEWLINE         reduce using rule 19 (expressions -> returner .)


state 59

    (13) statement -> DEF IDENTIFIER params NEWLINE expressions . NEWLINE ENDDEF
    (16) expressions -> expressions . NEWLINE expression
    (17) expressions -> expressions . NEWLINE returner

    NEWLINE         shift and go to state 64


state 60

    (18) expressions -> expression .

    NEWLINE         reduce using rule 18 (expressions -> expression .)


state 61

    (37) list -> LBRACKET optspace listelems optspace COMMA . RBRACKET
    (40) listelems -> listelems optspace COMMA . optspace arg
    (41) optspace -> . empty
    (42) optspace -> . NEWLINE
    (43) empty -> .

    RBRACKET        shift and go to state 65
    NEWLINE         shift and go to state 34
    IDENTIFIER      reduce using rule 43 (empty -> .)
    LPAREN          reduce using rule 43 (empty -> .)
    LBRACKET        reduce using rule 43 (empty -> .)
    STRING          reduce using rule 43 (empty -> .)
    NUMBER          reduce using rule 43 (empty -> .)
    BOOLEAN         reduce using rule 43 (empty -> .)

    optspace                       shift and go to state 66
    empty                          shift and go to state 18

state 62

    (36) list -> LBRACKET optspace listelems optspace RBRACKET .

    NEWLINE         reduce using rule 36 (list -> LBRACKET optspace listelems optspace RBRACKET .)
    IDENTIFIER      reduce using rule 36 (list -> LBRACKET optspace listelems optspace RBRACKET .)
    LPAREN          reduce using rule 36 (list -> LBRACKET optspace listelems optspace RBRACKET .)
    LBRACKET        reduce using rule 36 (list -> LBRACKET optspace listelems optspace RBRACKET .)
    STRING          reduce using rule 36 (list -> LBRACKET optspace listelems optspace RBRACKET .)
    NUMBER          reduce using rule 36 (list -> LBRACKET optspace listelems optspace RBRACKET .)
    BOOLEAN         reduce using rule 36 (list -> LBRACKET optspace listelems optspace RBRACKET .)
    RPAREN          reduce using rule 36 (list -> LBRACKET optspace listelems optspace RBRACKET .)
    ELSE            reduce using rule 36 (list -> LBRACKET optspace listelems optspace RBRACKET .)
    $end            reduce using rule 36 (list -> LBRACKET optspace listelems optspace RBRACKET .)
    GOTO            reduce using rule 36 (list -> LBRACKET optspace listelems optspace RBRACKET .)
    RBRACKET        reduce using rule 36 (list -> LBRACKET optspace listelems optspace RBRACKET .)
    COMMA           reduce using rule 36 (list -> LBRACKET optspace listelems optspace RBRACKET .)


state 63

    (21) returner -> RETURN arg .

    NEWLINE         reduce using rule 21 (returner -> RETURN arg .)


state 64

    (13) statement -> DEF IDENTIFIER params NEWLINE expressions NEWLINE . ENDDEF
    (16) expressions -> expressions NEWLINE . expression
    (17) expressions -> expressions NEWLINE . returner
    (7) expression -> . IDENTIFIER args
    (8) expression -> . STRING
    (11) expression -> . IS arg thenexpr elseexpr
    (12) expression -> . EXIT
    (20) returner -> . RETURN
    (21) returner -> . RETURN arg

    ENDDEF          shift and go to state 67
    IDENTIFIER      shift and go to state 1
    STRING          shift and go to state 13
    IS              shift and go to state 5
    EXIT            shift and go to state 10
    RETURN          shift and go to state 57

    returner                       shift and go to state 68
    expression                     shift and go to state 69

state 65

    (37) list -> LBRACKET optspace listelems optspace COMMA RBRACKET .

    NEWLINE         reduce using rule 37 (list -> LBRACKET optspace listelems optspace COMMA RBRACKET .)
    IDENTIFIER      reduce using rule 37 (list -> LBRACKET optspace listelems optspace COMMA RBRACKET .)
    LPAREN          reduce using rule 37 (list -> LBRACKET optspace listelems optspace COMMA RBRACKET .)
    LBRACKET        reduce using rule 37 (list -> LBRACKET optspace listelems optspace COMMA RBRACKET .)
    STRING          reduce using rule 37 (list -> LBRACKET optspace listelems optspace COMMA RBRACKET .)
    NUMBER          reduce using rule 37 (list -> LBRACKET optspace listelems optspace COMMA RBRACKET .)
    BOOLEAN         reduce using rule 37 (list -> LBRACKET optspace listelems optspace COMMA RBRACKET .)
    RPAREN          reduce using rule 37 (list -> LBRACKET optspace listelems optspace COMMA RBRACKET .)
    ELSE            reduce using rule 37 (list -> LBRACKET optspace listelems optspace COMMA RBRACKET .)
    $end            reduce using rule 37 (list -> LBRACKET optspace listelems optspace COMMA RBRACKET .)
    GOTO            reduce using rule 37 (list -> LBRACKET optspace listelems optspace COMMA RBRACKET .)
    RBRACKET        reduce using rule 37 (list -> LBRACKET optspace listelems optspace COMMA RBRACKET .)
    COMMA           reduce using rule 37 (list -> LBRACKET optspace listelems optspace COMMA RBRACKET .)


state 66

    (40) listelems -> listelems optspace COMMA optspace . arg
    (29) arg -> . IDENTIFIER
    (30) arg -> . list
    (31) arg -> . literal
    (35) arg -> . LPAREN funcall RPAREN
    (36) list -> . LBRACKET optspace listelems optspace RBRACKET
    (37) list -> . LBRACKET optspace listelems optspace COMMA RBRACKET
    (38) list -> . LBRACKET optspace RBRACKET
    (32) literal -> . STRING
    (33) literal -> . NUMBER
    (34) literal -> . BOOLEAN

    IDENTIFIER      shift and go to state 28
    LPAREN          shift and go to state 26
    LBRACKET        shift and go to state 20
    STRING          shift and go to state 21
    NUMBER          shift and go to state 23
    BOOLEAN         shift and go to state 25

    list                           shift and go to state 22
    literal                        shift and go to state 24
    arg                            shift and go to state 70

state 67

    (13) statement -> DEF IDENTIFIER params NEWLINE expressions NEWLINE ENDDEF .

    NEWLINE         reduce using rule 13 (statement -> DEF IDENTIFIER params NEWLINE expressions NEWLINE ENDDEF .)
    $end            reduce using rule 13 (statement -> DEF IDENTIFIER params NEWLINE expressions NEWLINE ENDDEF .)


state 68

    (17) expressions -> expressions NEWLINE returner .

    NEWLINE         reduce using rule 17 (expressions -> expressions NEWLINE returner .)


state 69

    (16) expressions -> expressions NEWLINE expression .

    NEWLINE         reduce using rule 16 (expressions -> expressions NEWLINE expression .)


state 70

    (40) listelems -> listelems optspace COMMA optspace arg .

    NEWLINE         reduce using rule 40 (listelems -> listelems optspace COMMA optspace arg .)
    RBRACKET        reduce using rule 40 (listelems -> listelems optspace COMMA optspace arg .)
    COMMA           reduce using rule 40 (listelems -> listelems optspace COMMA optspace arg .)

